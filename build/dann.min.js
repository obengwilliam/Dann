const isBrowser="object"!=typeof process;let fs,w;function addCDNdependencies(){let t=document.createElement("script");t.setAttribute("type","text/javascript"),t.setAttribute("src","https://cdn.jsdelivr.net/npm/mathjs@8.1.0/lib/browser/math.min.js"),document.head.insertBefore(t,document.head.children[0])}function downloadSTR(t,e){let s="data:text/json;charset=utf-8,"+encodeURIComponent(JSON.stringify(t)),r=document.createElement("a");r.setAttribute("href",s),r.setAttribute("download",e+".json"),document.body.appendChild(r),r.click(),r.remove()}function domInput(t,e,s){let r="";void 0!==s&&(r=","+s.toString());let o=document.createElement("input");o.setAttribute("type","file"),o.setAttribute("id","upload"),o.setAttribute("onChange","clickedUpload("+t+r+")");try{void 0!==e?document.getElementById(e).appendChild(o):document.body.appendChild(o)}catch(r){r&&window.addEventListener("load",(function(){domInput(t,e,s)}))}}function upload(t,e,s){try{domInput(t,e,s)}catch(t){console.log(t)}}function clickedUpload(nn,callback){let callfunc=eval(callback),element=document.getElementById("upload"),file=element.files[0],reader=new FileReader,newNN;reader.readAsText(file),reader.onload=function(){if("{"==reader.result[0]){let t=JSON.parse(reader.result);newNN=t,nn.applyToModel(newNN),void 0!==callfunc?callfunc(!1):console.log("Succesfully loaded the file.")}else void 0!==callfunc?callfunc(!0):console.log("Error loading the file.")},reader.onerror=function(){void 0!==callfunc?callfunc(!0):console.log(reader.error)},element.remove()}isBrowser?addCDNdependencies():(fs=require("fs"),require("mathjs"),w=require("@fast-csv/format"));const random=(t,e)=>Math.random(1)*(e-t)+t,exp=t=>Math.exp(t),abs=t=>Math.abs(t),log=t=>Math.log(t),logn=(t,e)=>log(t)/log(e),pow=(t,e)=>Math.pow(t,e),sin=t=>Math.sin(t),cos=t=>Math.cos(t),tan=t=>Math.tan(t),round=t=>Math.round(t),sqrt=t=>Math.sqrt(t),cosh=t=>(exp(t)+exp(-t))/2,sech=t=>1/cosh(t);function sigmoid(t){return 1/(1+exp(-t))}function sigmoid_d(t){let e=sigmoid(t);return e*(1-e)}function leakySigmoid(t){return 1/(1+exp(-t))+t/100}function leakySigmoid_d(t){let e=leakySigmoid(t);return e*(1-e)}function siLU(t){return t/(1+exp(-t))}function siLU_d(t){return(1+exp(-t)+t*exp(-t))/pow(1+exp(-t),2)}function tanH(t){return(exp(t)-exp(-t))/(exp(t)+exp(-t))}function tanH_d(t){return 1-pow(tanH(t),2)}function leakyReLUCapped(t){return t>=0&&t<=6?t:t<0?.1*t:6}function leakyReLUCapped_d(t){return t>=0&&t<=6?1:t<0?.1:0}function leakyReLU(t){return t>=0?1*t:.01*t}function leakyReLU_d(t){return t>=0?1:.01}function reLU(t){return t>=0?1*t:0}function reLU_d(t){return t>=0?1:0}function mae(t,e){let s=0,r=0,o=e.length;for(let r=0;r<o;r++){let o=e[r],i=t[r];s+=abs(o-i)}return r=s/o,r}function bce(t,e){let s=0,r=0,o=e.length;for(let r=0;r<o;r++){let o=e[r],i=t[r];s+=o*log(i)+(1-o)*log(1-i)}return r=-s/o,r}function lcl(t,e){let s=0,r=0,o=e.length;for(let r=0;r<o;r++){let o=e[r],i=t[r];s+=log(cosh(i-o))}return r=s/o,r}function mbe(t,e){let s=0,r=0,o=e.length;for(let r=0;r<o;r++){s+=e[r]-t[r]}return r=s/o,r}function mael(t,e){let s=0,r=0,o=e.length;for(let r=0;r<o;r++){let o=e[r]-t[r];s+=-o*(exp(-o)-1)/(exp(-o)+1)}return r=s/o,r}function rmse(t,e){let s=0,r=0,o=e.length;for(let r=0;r<o;r++){let o=e[r],i=t[r];s+=pow(o-i,2)}return r=sqrt(s/o),r}function mce(t,e){let s=0,r=0,o=e.length;for(let r=0;r<o;r++){let o=e[r],i=t[r];s+=pow(abs(o-i),3)}return r=s/o,r}function mse(t,e){let s=0,r=0,o=e.length;for(let r=0;r<o;r++){let o=e[r],i=t[r];s+=pow(o-i,2)}return r=s/o,r}function max(t){let e=0,s=t.length;for(let r=0;r<s;r++)t[r]>e&&(e=t[r]);return e}function min(t){let e=1/0,s=t.length;for(let r=0;r<s;r++)t[r]<e&&(e=t[r]);return e}function avg(t){let e=0,s=t.length;for(let r=0;r<s;r++)e+=t[r];return e/s}class Matrix{constructor(t,e){this.rows=t,this.cols=e,this.matrix=Matrix.make(t,e)}static toArray(t){let e=[];if(1==t.cols)for(let s=0;s<t.rows;s++)e[s]=t.matrix[s][0];return e}static fromArray(t){let e=new Matrix(t.length,1);for(let s=0;s<t.length;s++)e.matrix[s][0]=t[s];return e}static transpose(t){let e=new Matrix(t.cols,t.rows);for(let s=0;s<t.rows;s++)for(let r=0;r<t.cols;r++)e.matrix[r][s]=t.matrix[s][r];return e}static map(t,e){for(let s=0;s<t.rows;s++)for(let r=0;r<t.cols;r++){let o=t.matrix[s][r];t.matrix[s][r]=e(o)}return t}static addition(t,e){let s=t,r=e,o=new Matrix(s.rows,s.cols);if(s.rows===r.rows&&s.cols===r.cols){for(let t=0;t<o.rows;t++)for(let e=0;e<o.cols;e++)o.matrix[t][e]=s.matrix[t][e]-r.matrix[t][e];return o}}static subtract(t,e){let s=t,r=e,o=new Matrix(s.rows,s.cols);if(s instanceof Matrix&&r instanceof Matrix)for(let t=0;t<o.rows;t++)for(let e=0;e<o.cols;e++)o.matrix[t][e]=s.matrix[t][e]-r.matrix[t][e];return o}static multiply(t,e,s){let r="cpu";if(void 0!==s&&s.mode&&(r=s.mode),"cpu"!=r)return"gpu"==r?(console.log("gpu coming soon"),r="cpu",Matrix.multiply(t,e)):(console.error("Dann Error: mode specified is not valid"),void console.trace());{let s=t,r=e,o=new Matrix(s.rows,r.cols);if(t instanceof Matrix&&e instanceof Matrix){if(s.cols!==r.rows)return console.log(s,r),console.error("not compatible"),void console.trace();for(let t=0;t<o.rows;t++)for(let e=0;e<o.cols;e++){let i=0;for(let o=0;o<s.cols;o++)i+=s.matrix[t][o]*r.matrix[o][e];o.matrix[t][e]=i}return o}}}static make(t,e){let s=[];for(let r=0;r<t;r++){s[r]=[];for(let t=0;t<e;t++)s[r][t]=0}return s}insert(t,e,s){return"number"!=typeof t?(console.error('Dann error: first "value" argument is not a number'),void console.trace()):"number"!=typeof e?(console.error('Dann error: second "x" argument is not a number'),void console.trace()):"number"!=typeof s?(console.error('Dann error: third "y" argument is not a number'),void console.trace()):void(e<this.cols&&s<this.rows?this.matrix[s][e]=t:(console.error("Dann error: x,y arguments exceed the matrix dimensions."),console.trace()))}addRandom(t,e){let s=Matrix.make(this.rows,this.cols);for(let r=0;r<this.rows;r++)for(let o=0;o<this.cols;o++){let i=this.matrix[r][o];random(0,1)<e&&(s[r][o]=i+i*random(-t,t))}this.set(s)}addPrecent(t){for(let e=0;e<this.rows;e++)for(let s=0;s<this.cols;s++){let r=this.matrix[e][s];this.matrix[e][s]+=r*t}}set(t){if("number"!=typeof t.length||"number"!=typeof t[0].length||"object"!=typeof t)return console.error("Dann error: the argument of set(); must be an array within an array. Here is an example: [[1,0],[0,1]]"),void console.trace();this.matrix=t,this.rows=t.length,this.cols=t[0].length}add(t){if(t instanceof Matrix){if(this.rows!==t.rows||this.cols!==t.cols)return;for(let e=0;e<this.rows;e++)for(let s=0;s<this.cols;s++)this.matrix[e][s]+=t.matrix[e][s]}else for(let e=0;e<this.rows;e++)for(let s=0;s<this.cols;s++)this.matrix[e][s]+=t}sub(t){for(let e=0;e<this.rows;e++)for(let s=0;s<this.cols;s++)this.matrix[e][s]-=t}mult(t){if(t instanceof Matrix){if(this.rows!==t.rows||this.cols!==t.cols)return void console.log("rows of A must match rows of B");for(let e=0;e<this.rows;e++)for(let s=0;s<this.cols;s++)this.matrix[e][s]*=t.matrix[e][s]}else for(let e=0;e<this.rows;e++)for(let s=0;s<this.cols;s++)this.matrix[e][s]*=t}log(t){let e=1e3,s=!1;void 0!==t&&(t.decimals&&(e=pow(10,t.decimals)),t.table&&(s=t.table));let r=new Matrix(this.rows,this.cols);for(let t=0;t<this.rows;t++)for(let s=0;s<this.cols;s++){let o=this.matrix[t][s];r.insert(round(o*e)/e,s,t)}s?console.table(r.matrix):console.log(r)}initiate(t){let e=0;if(void 0!==t){if("number"!=typeof t)return console.error("Dann error: the value entered as an argument is not a number"),void console.trace();e=t}for(let t=0;t<this.matrix.length;t++)for(let s=0;s<this.matrix[t].length;s++)this.matrix[t][s]=e}map(t){for(let e=0;e<this.rows;e++)for(let s=0;s<this.cols;s++){let r=this.matrix[e][s];this.matrix[e][s]=t(r)}}randomize(t,e){for(let s=0;s<this.matrix.length;s++)for(let r=0;r<this.matrix[s].length;r++)this.matrix[s][r]=random(t,e)}}class Layer{constructor(t,e,s,r,o,i){if(this.type=t,this.subtype=Layer.getSubtype(t),"pool"!==this.subtype)"hidden"==this.type||"output"==this.type?(this.size=e,this.setAct(s),this.layer=new Matrix(this.size,1)):"input"==this.type&&(this.size=e,this.layer=new Matrix(this.size,1));else if("pool"==this.subtype){if(this.stride=r,this.sampleSize=s,this.inputSize=e,void 0!==o&&void 0!==i)this.sizeX=o,this.sizeY=i;else if(this.sizeX=Math.sqrt(this.inputSize),this.sizeY=this.sizeX,this.sizeX!==Math.floor(this.sizeX))return console.error("Dann Error: the array can not be set in a square matrix"),void console.trace();this.size=Layer.getPoolOutputLength(e,s,r,this.sizeX,this.sizeY);let t=this.inputSize/this.sizeX,n=this.inputSize/this.sizeY;if(t!==Math.floor(t)&&n!==Math.floor(n))return console.error("Dann Error: the width & height value specified to arrange the inputted array as a matrix are not valid. (The array length must be divisible by the width & height values.)"),void console.trace();if(this.size!==Math.floor(this.size))return console.error("Dann Error: the Width must be divisible by the stride (jumps size). Width is the root of the array's length."),void console.trace();this.input=new Matrix(this.inputSize,1),this.layer=new Matrix(this.size,1),this.prefix=Layer.getPrefix(this.type,4),this.poolfunc=poolfuncs[this.prefix],this.downsample=function(t,e,s){this.input=Matrix.fromArray(t);let r=Layer.selectPools(t,e,s,this.sizeX,this.sizeY),o=[];for(let t=0;t<r.length;t++)o[t]=this.poolfunc(r[t]);return this.layer=Matrix.fromArray(o),o},this.feed=function(t,e){let s=!1,r=!1,o=this.sampleSize,i=this.stride;if(void 0!==e&&(e.log&&(s=e.log),e.table&&(r=e.table)),t.length!==this.inputSize)return console.error("Dann Error: The data you are trying to feed to this "+this.type+" layer is not the same length as the number of input this layer has."),void console.trace();{let e=this.downsample(t,o,i);return s&&(r?console.table(e):console.log(e)),e}}}else"string"==typeof this.type?(console.error("Dann Error: The Layer type '"+this.type+"' is not valid."),console.trace()):(console.error("Dann Error: You need to specify a valid type of Layer"),console.trace())}static stringTofunc(t){let e,s,r=t,o=r+"_d";if(isBrowser?(e=window[r],s=window[o]):(e=activations[r],s=activations[o]),void 0!==e)return void 0!==s?{name:r,name_d:o,func:e,func_d:s}:(console.error("Dann Error: You need to create the derivative of your custom function. The activation function specified '"+t+"' does not have a derivative assigned. The activation function was set to the default 'sigmoid'."),void console.trace());console.error("Dann Error: the activation function '"+t+"' is not a valid activation function. The activation function was set to the default 'sigmoid'."),console.trace()}static getPrefix(t,e){let s=t.length;return t.slice(0,s-4)}static getSubtype(t){let e=t.length,s=t.slice(e-4,e);return"pool"==s?s:t}static getSqIndex(t,e,s){return t*s+e}static selectPools(t,e,s,r,o){t.length;if(r!==Math.floor(r))return;if(r/s!==Math.floor(r/s))return;let i=[];for(let n=0;n+e<=o;n+=s)for(let o=0;o+e<=r;o+=s){let s=[];for(let i=0;i<e;i++)for(let a=0;a<e;a++)s.push(t[Layer.getSqIndex(r,a+o,i+n)]);i.push(s)}return i}static getPoolOutputLength(t,e,s,r,o){return((r-e)/s+1)*((o-e)/s+1)}setAct(t){let e=Layer.stringTofunc(t);this.setFunc(e)}setFunc(t){void 0!==t&&(this.actname=t.name,this.actname_d=t.name_d,this.actfunc=t.func,this.actfunc_d=t.func_d)}log(){console.log(this)}}class Dann{constructor(t=1,e=1){this.i=t,this.inputs=new Layer("input",t),this.o=e,this.outputs=new Layer("output",e,"sigmoid"),this.Layers=[this.inputs,this.outputs],this.weights=[],this.biases=[],this.errors=[],this.gradients=[],this.outs=[],this.loss=0,this.losses=[],this.lr=.001,this.arch=[t,e],this.epoch=0,this.recordLoss=!1,this.lossfunc=mse,this.lossfunc_s=this.lossfunc.name}setLossFunction(t){let e=lossfuncs[t];if(null==e)return"string"==typeof t?(console.error("Dann Error: '"+t+"' is not a valid loss function, as a result, the model's loss function is set to 'mse' by default."),void console.trace()):(console.error("Dann Error: Did not detect string value, as a result, the loss function is set to 'mse' by default."),void console.trace());this.lossfunc_s=t,this.lossfunc=e}outputActivation(t){if(null==activations[t]&&!isBrowser)return"string"==typeof t?(console.error("Dann Error: '"+t+"' is not a valid activation function, as a result, the activation function is set to 'sigmoid' by default."),void console.trace()):(console.error("Dann Error: Did not detect a string value, as a result, the activation function is set to 'sigmoid' by default."),void console.trace());this.Layers[this.Layers.length-1].setAct(t)}makeWeights(t,e){let s=-1,r=1;void 0!==t&&void 0!==e&&(s=t,r=e);for(let t=0;t<this.Layers.length-1;t++){let e=this.Layers[t],o=this.Layers[t+1],i=new Matrix(o.layer.rows,e.layer.rows),n=new Matrix(o.layer.rows,1);if(i.randomize(s,r),n.randomize(1,-1),this.weights[t]=i,this.biases[t]=n,this.errors[t]=new Matrix(o.layer.rows,1),this.gradients[t]=new Matrix(o.layer.rows,1),null==o.actfunc){let t=Layer.stringTofunc("sigmoid");o.setFunc(t)}}for(let t=0;t<this.Layers.length;t++){let e=this.Layers[t];this.arch[t]=e.layer.rows}}addHiddenLayer(t,e){if(null==activations[e])return"string"==typeof e?(console.error("Dann Error: '"+e+"' is not a valid activation function, as a result, the activation function is set to 'sigmoid' by default."),void console.trace()):(console.error("Dann Error: Did not detect a string value, as a result, the activation function is set to 'sigmoid' by default."),void console.trace());let s=new Layer("hidden",t,e);this.Layers.splice(this.Layers.length-1,0,s)}feedForward(t,e){let s=!1,r="cpu",o=!1,i=!1,n=1e3;if(void 0!==e&&(s=void 0!==e.log&&e.log,void 0!==e.decimals&&(e.decimals>21&&(console.error("Dann Error: Maximum number of decimals is 21."),console.trace(),e.decimals=21),n=pow(10,e.decimals),i=!0),void 0!==e.table&&(o=e.table),void 0!==e.mode?(r=e.mode,"gpu"==r&&(console.warn("Gpu support in the works."),r="cpu")):r="cpu"),t.length!=this.i){for(let t=0;t<this.o;t++)this.outs[t]=0;return console.error("Dann Error: The input array length does not match the number of inputs the dannjs model has."),console.trace(),this.outs}this.Layers[0].layer=Matrix.fromArray(t),0===this.weights.length&&(console.warn("Dann Warning: The weights were not initiated. Please use the Dann.makeWeights(); function after the initialization of the layers."),this.makeWeights());for(let t=0;t<this.weights.length;t++){let e=this.Layers[t],s=this.Layers[t+1];s.layer=Matrix.multiply(this.weights[t],e.layer),s.layer.add(this.biases[t]),s.layer.map(s.actfunc)}this.outs=Matrix.toArray(this.Layers[this.Layers.length-1].layer);let a=this.outs;return 1==s&&(1==i&&(a=a.map(t=>round(t*n)/n)),1==o?(console.log("Prediction: "),console.table(a)):console.log("Prediction: ",a)),a}backpropagate(t,e,s){let r=!1,o="cpu",i=!1,n=!1;void 0!==s&&(r=void 0!==s.log&&s.log,void 0!==s.table&&(n=s.table),void 0!==s.mode?(o=s.mode,"gpu"==o&&console.log("gpu version coming soon")):o="cpu",i=void 0===s.saveLoss||s.saveLoss);let a=new Matrix(0,0);if(e.length!=this.o)return console.error("Dann Error: The target array length does not match the number of ouputs the dannjs model has."),void console.trace();if(a=Matrix.fromArray(e),"number"!=typeof this.lr)return console.error("Dann Error: The learning rate specified (Dann.lr property) is not a number."),void console.trace();this.outs=this.feedForward(t,{log:!1,mode:o}),this.errors[this.errors.length-1]=Matrix.subtract(a,this.Layers[this.Layers.length-1].layer),this.gradients[this.gradients.length-1]=Matrix.map(this.Layers[this.Layers.length-1].layer,this.Layers[this.Layers.length-1].actfunc_d),this.gradients[this.gradients.length-1].mult(this.errors[this.errors.length-1]),this.gradients[this.gradients.length-1].mult(this.lr);for(let t=this.weights.length-1;t>0;t--){let e=Matrix.transpose(this.Layers[t].layer),s=Matrix.multiply(this.gradients[t],e);this.weights[t].add(s),this.biases[t].add(this.gradients[t]);let r=Matrix.transpose(this.weights[t]);this.errors[t-1]=Matrix.multiply(r,this.errors[t]),this.gradients[t-1]=Matrix.map(this.Layers[t].layer,this.Layers[t].actfunc_d),this.gradients[t-1].mult(this.errors[t-1]),this.gradients[t-1].mult(this.lr)}let l=Matrix.transpose(this.Layers[0].layer),h=Matrix.multiply(this.gradients[0],l);this.weights[0].add(h),this.biases[0].add(this.gradients[0]),this.loss=this.lossfunc(this.outs,e),1==i&&this.losses.push(this.loss),1==r&&(console.log("Prediction: "),n?console.table(this.outs):console.log(this.outs),console.log("target: "),n?console.table(e):console.log(e),console.log("Loss: ",this.loss))}mutateRandom(t,e){if("number"!=typeof t)return console.error("Dann Error: Dann.mutateRandom(); range argument must be a number."),void console.trace();if(void 0!==e){if("number"!=typeof e)return console.error("Dann Error: Dann.mutateRandom(); probability argument must be a number."),void console.trace()}else e=1;for(let s=0;s<this.weights.length;s++)this.weights[s].addRandom(t,e)}mutateAdd(t){if("number"!=typeof t)return console.error("Dann Error: Dann.mutateAdd(); percent argument must be a number."),void console.trace();for(let e=0;e<this.weights.length;e++)this.weights[e].addPrecent(t)}static createFromObject(t){const e=new Dann;return e.applyToModel(t),e}dataObject(){let t=[];for(let e=0;e<this.weights.length;e++)t[e]=JSON.stringify(this.weights[e].matrix);let e=JSON.stringify(t),s=[];for(let t=0;t<this.Layers.length;t++)s[t]=JSON.stringify(this.Layers[t]);let r=JSON.stringify(s),o=[];for(let t=0;t<this.biases.length;t++)o[t]=JSON.stringify(this.biases[t].matrix);let i=JSON.stringify(o),n=[];for(let t=0;t<this.errors.length;t++)n[t]=JSON.stringify(this.errors[t].matrix);let a=JSON.stringify(n),l=[];for(let t=0;t<this.gradients.length;t++)l[t]=JSON.stringify(this.gradients[t].matrix);return{wstr:e,lstr:r,bstr:i,estr:a,gstr:JSON.stringify(l),arch:this.arch,lrate:this.lr,lf:this.lossfunc_s,loss:this.loss,e:this.epoch}}save(t,e){let s,r=!1,o=!1,i=0,n="none";if(void 0!==e&&(void 0!==e.report&&(o=e.report),void 0!==e.test))if("function"==typeof e.test){i=100*(0,e.test)(),n=i+"%"}else console.error("Dann Error: the test option can only be a function."),console.trace();let a=this.dataObject();if(isBrowser)downloadSTR(a,t);else{if(s="./savedDanns/"+t+"/dannData.json",fs.existsSync(s)&&(r=!0),fs.existsSync("./savedDanns")||fs.mkdirSync("./savedDanns"),fs.existsSync("./savedDanns/"+t)||fs.mkdirSync("./savedDanns/"+t),1==o){let s=[];for(let t=1;t<this.arch.length;t++)s[t-1]=this.Layers[t].actname;let r=[];r.push(["Dann","train report"]),r.push(["Arch: ",this.arch]),r.push(["Acts: ",s]),r.push(["Lr: ",this.lr]),r.push(["Epoch:",this.epoch]),"function"==typeof e.test&&r.push(["Accuracy:",n]),r.push(["Index","AvgLoss"]);for(let t=0;t<this.losses.length;t++)r.push([t+1,this.losses[t]]);w.writeToPath("./savedDanns/"+t+"/report.csv",r).on("error",t=>console.error(t)).on("finish",()=>console.log("saved training report at ./savedDanns/"+t+"/report.csv"))}fs.writeFileSync(s,JSON.stringify(a)),1==r?(console.log("[32m",""),this.log(),console.log("Succesfully overwritten the Dann Model at ./savedDanns/"+t+"/dannData.json "),console.log("[0m","")):(console.log("[32m",""),this.log(),console.log("Succesfully saved the Dann Model at ./savedDanns/"+t+"/dannData.json "),console.log("[0m",""))}}applyToModel(t){this.i=t.arch[0],this.inputs=new Matrix(this.i,1),this.o=t.arch[t.arch.length-1],this.outputs=new Matrix(this.o,1);let e=JSON.parse(t.lstr);for(let t=0;t<e.length;t++){let s=JSON.parse(e[t]),r=new Layer(s.type,s.size,s.actname);this.Layers[t]=r}this.makeWeights();let s=JSON.parse(t.wstr);for(let t=0;t<s.length;t++)this.weights[t].set(JSON.parse(s[t]));let r=JSON.parse(t.bstr);for(let t=0;t<r.length;t++)this.biases[t].set(JSON.parse(r[t]));let o=JSON.parse(t.estr);for(let t=0;t<o.length;t++)this.errors[t].set(JSON.parse(o[t]));let i=JSON.parse(t.gstr);for(let t=0;t<i.length;t++)this.gradients[t].set(JSON.parse(i[t]));return this.lossfunc_s=t.lf,this.lossfunc=isBrowser?window[t.lf]:lossfuncs[t.lf],this.outs=Matrix.toArray(this.Layers[this.Layers.length-1]),this.loss=t.loss,this.losses=[],this.lr=t.lrate,this.arch=t.arch,this.epoch=t.e,this}static createModelFromJSON(t,e){let s=new Dann(0,0);return s.applyToModel(JSON.stringify(e)),Object.assign(s,t)}load(t,e,s){if(isBrowser)upload(t,e,s);else{let s="./savedDanns/"+t+"/dannData.json";if(fs.existsSync(s)){let t=fs.readFileSync(s,"utf8"),r=JSON.parse(t);if(this.applyToModel(r),"function"==typeof e)e(!1);else{let t=typeof e;console.error("Dann Error: callback specified is not a function, the funtion recieved a "+t+" instead"),console.trace()}}else if("function"==typeof e)e(!0);else if("function"!=typeof e){let t=typeof e;console.error("Dann Error: callback specified is not a function, the funtion recieved a "+t+" instead"),console.trace()}else console.error("Dann Error: file not found"),console.trace()}}log(t){let e=!1,s=!1,r=!1,o=!1,i=!1,n=!1,a=!1,l=!1,h=1e3;if(void 0!==t){if(t.weights&&(e=t.weights),t.gradients&&(s=t.gradients),t.errors&&(r=t.errors),t.biases&&(o=t.biases),t.struct&&(i=t.struct),t.misc&&(n=t.misc),t.table&&(l=t.table),t.layers&&(a=t.layers,i=t.layers),t.details){let l=t.details;s=l,e=l,r=l,o=l,i=l,n=l,a=l}t.decimals&&(t.decimals>21&&(console.error("Dann Error: Maximum number of decimals is 21."),console.trace(),t.decimals=21),h=pow(10,t.decimals))}else i=!0,n=!0;if(0===this.weights.length&&this.makeWeights(),(null==t||void 0!==t&&1==t.details)&&console.log("Dann NeuralNetwork:"),i){console.log("  Layers:");for(let t=0;t<this.Layers.length;t++){let e=this.Layers[t],s=e.type+" Layer: ",r="";0==t?(s="Input Layer:   ",r="       "):t==e.length-1?(s="Output Layer:  ",r="  ("+e.actname+")"):r="  ("+e.actname+")",console.log("    "+s+e.size+r),a&&console.log(this.Layers[t])}}if(r){console.log("  Errors:");for(let t=0;t<this.errors.length;t++){let e=Matrix.toArray(this.errors[t]),s=[];for(let t=0;t<e.length;t++)s[t]=round(e[t]*h)/h;console.log(s)}}if(s){console.log("  Gradients:");for(let t=0;t<this.gradients.length;t++){let e=Matrix.toArray(this.gradients[t]),s=[];for(let t=0;t<e.length;t++)s[t]=round(e[t]*h)/h;console.log(s)}}if(e){console.log("  Weights:");for(let e=0;e<this.weights.length;e++){this.weights[e].log({decimals:t.decimals,table:l})}}if(o){console.log("  Biases:");for(let t=0;t<this.biases.length;t++){let e=Matrix.toArray(this.biases[t]),s=[];for(let t=0;t<e.length;t++)s[t]=round(e[t]*h)/h;console.log(s)}}n&&(console.log("  Other Values: "),console.log("    Learning rate: "+this.lr),console.log("    Loss Function: "+this.lossfunc.name),console.log("    Current Epoch: "+this.epoch),console.log("    Latest Loss: "+this.loss)),console.log(" ")}}const XOR=[{input:[1,0],output:[1]},{input:[0,1],output:[1]},{input:[0,0],output:[0]},{input:[1,1],output:[0]}];function bitLength(t){return t<1?1:Math.floor(Math.log(t)/Math.log(2))+1}function numberToBinary(t,e){let s=t.toString(2),r=[],o=bitLength(t)-1;for(let t=e-1;t>=0;t--){let e=s.charAt(o);r[t]=""==e?0:JSON.parse(e),o--}return r}function makeBinary(t,e){let s;s=void 0!==e?e:function(t){return t+1};let r=[];Math.pow(2,t),bitLength(t);for(let e=0;e<Math.pow(2,t)-1;e++){let o=s(e);if(bitLength(o)<=t){let s={input:numberToBinary(e,t),target:numberToBinary(o,t)};r.push(s)}}return r}let activations={sigmoid:sigmoid,sigmoid_d:sigmoid_d,tanH:tanH,tanH_d:tanH_d,siLU:siLU,siLU_d:siLU_d,reLU:reLU,reLU_d:reLU_d,leakyReLU:leakyReLU,leakyReLU_d:leakyReLU_d,leakySigmoid:leakySigmoid,leakySigmoid_d:leakySigmoid_d,leakyReLUCapped:leakyReLUCapped,leakyReLUCapped_d:leakyReLUCapped_d},lossfuncs={mae:mae,bce:bce,lcl:lcl,mbe:mbe,mce:mce,mse:mse,rmse:rmse,mael:mael},poolfuncs={max:max,min:min,avg:avg};isBrowser||(module.exports={dann:Dann,layer:Layer,matrix:Matrix,activations:activations,lossfuncs:lossfuncs,poolfuncs:poolfuncs,xor:XOR,makeBinary:makeBinary});